( () => {
    var qv = Object.create;
    var Hi = Object.defineProperty;
    var $v = Object.getOwnPropertyDescriptor;
    var Lv = Object.getOwnPropertyNames;
    var Mv = Object.getPrototypeOf
      , Nv = Object.prototype.hasOwnProperty;
    var df = r => Hi(r, "__esModule", {
        value: !0
    });
    var hf = r => {
        if (typeof require != "undefined")
            return require(r);
        throw new Error('Dynamic require of "' + r + '" is not supported')
    }
    ;
    var P = (r, e) => () => (r && (e = r(r = 0)),
    e);
    var x = (r, e) => () => (e || r((e = {
        exports: {}
    }).exports, e),
    e.exports)
      , Ge = (r, e) => {
        df(r);
        for (var t in e)
            Hi(r, t, {
                get: e[t],
                enumerable: !0
            })
    }
      , Bv = (r, e, t) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Lv(e))
                !Nv.call(r, i) && i !== "default" && Hi(r, i, {
                    get: () => e[i],
                    enumerable: !(t = $v(e, i)) || t.enumerable
                });
        return r
    }
      , pe = r => Bv(df(Hi(r != null ? qv(Mv(r)) : {}, "default", r && r.__esModule && "default"in r ? {
        get: () => r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
    var m, u = P( () => {
        m = {
            platform: "",
            env: {},
            versions: {
                node: "14.17.6"
            }
        }
    }
    );
    var Fv, be, ft = P( () => {
        u();
        Fv = 0,
        be = {
            readFileSync: r => self[r] || "",
            statSync: () => ({
                mtimeMs: Fv++
            }),
            promises: {
                readFile: r => Promise.resolve(self[r] || "")
            }
        }
    }
    );
    var Fs = x( (oP, gf) => {
        u();
        "use strict";
        var mf = class {
            constructor(e={}) {
                if (!(e.maxSize && e.maxSize > 0))
                    throw new TypeError("`maxSize` must be a number greater than 0");
                if (typeof e.maxAge == "number" && e.maxAge === 0)
                    throw new TypeError("`maxAge` must be a number greater than 0");
                this.maxSize = e.maxSize,
                this.maxAge = e.maxAge || 1 / 0,
                this.onEviction = e.onEviction,
                this.cache = new Map,
                this.oldCache = new Map,
                this._size = 0
            }
            _emitEvictions(e) {
                if (typeof this.onEviction == "function")
                    for (let[t,i] of e)
                        this.onEviction(t, i.value)
            }
            _deleteIfExpired(e, t) {
                return typeof t.expiry == "number" && t.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, t.value),
                this.delete(e)) : !1
            }
            _getOrDeleteIfExpired(e, t) {
                if (this._deleteIfExpired(e, t) === !1)
                    return t.value
            }
            _getItemValue(e, t) {
                return t.expiry ? this._getOrDeleteIfExpired(e, t) : t.value
            }
            _peek(e, t) {
                let i = t.get(e);
                return this._getItemValue(e, i)
            }
            _set(e, t) {
                this.cache.set(e, t),
                this._size++,
                this._size >= this.maxSize && (this._size = 0,
                this._emitEvictions(this.oldCache),
                this.oldCache = this.cache,
                this.cache = new Map)
            }
            _moveToRecent(e, t) {
                this.oldCache.delete(e),
                this._set(e, t)
            }
            *_entriesAscending() {
                for (let e of this.oldCache) {
                    let[t,i] = e;
                    this.cache.has(t) || this._deleteIfExpired(t, i) === !1 && (yield e)
                }
                for (let e of this.cache) {
                    let[t,i] = e;
                    this._deleteIfExpired(t, i) === !1 && (yield e)
                }
            }
            get(e) {
                if (this.cache.has(e)) {
                    let t = this.cache.get(e);
                    return this._getItemValue(e, t)
                }
                if (this.oldCache.has(e)) {
                    let t = this.oldCache.get(e);
                    if (this._deleteIfExpired(e, t) === !1)
                        return this._moveToRecent(e, t),
                        t.value
                }
            }
