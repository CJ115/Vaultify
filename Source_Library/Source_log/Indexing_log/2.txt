( () => {
    var qv = Object.create;
    var Hi = Object.defineProperty;
    var $v = Object.getOwnPropertyDescriptor;
    var Lv = Object.getOwnPropertyNames;
    var Mv = Object.getPrototypeOf
      , Nv = Object.prototype.hasOwnProperty;
    var df = r => Hi(r, "__esModule", {
        value: !0
    });
    var hf = r => {
        if (typeof require != "undefined")
            return require(r);
        throw new Error('Dynamic require of "' + r + '" is not supported')
    }
    ;
    var P = (r, e) => () => (r && (e = r(r = 0)),
    e);
    var x = (r, e) => () => (e || r((e = {
        exports: {}
    }).exports, e),
    e.exports)
      , Ge = (r, e) => {
        df(r);
        for (var t in e)
            Hi(r, t, {
                get: e[t],
                enumerable: !0
            })
    }
      , Bv = (r, e, t) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Lv(e))
                !Nv.call(r, i) && i !== "default" && Hi(r, i, {
                    get: () => e[i],
                    enumerable: !(t = $v(e, i)) || t.enumerable
                });
        return r
    }
      , pe = r => Bv(df(Hi(r != null ? qv(Mv(r)) : {}, "default", r && r.__esModule && "default"in r ? {
        get: () => r.default,
        enumerable: !0
    } : {
        value: r,
        enumerable: !0
    })), r);
    var m, u = P( () => {
        m = {
            platform: "",
            env: {},
            versions: {
                node: "14.17.6"
            }
        }
    }
    );
    var Fv, be, ft = P( () => {
        u();
        Fv = 0,
        be = {
            readFileSync: r => self[r] || "",
            statSync: () => ({
                mtimeMs: Fv++
            }),
            promises: {
                readFile: r => Promise.resolve(self[r] || "")
            }
        }
    }
    );
    var Fs = x( (oP, gf) => {
        u();
        "use strict";
        var mf = class {
            constructor(e={}) {
                if (!(e.maxSize && e.maxSize > 0))
                    throw new TypeError("`maxSize` must be a number greater than 0");
                if (typeof e.maxAge == "number" && e.maxAge === 0)
                    throw new TypeError("`maxAge` must be a number greater than 0");
                this.maxSize = e.maxSize,
                this.maxAge = e.maxAge || 1 / 0,
                this.onEviction = e.onEviction,
                this.cache = new Map,
                this.oldCache = new Map,
                this._size = 0
            }
            _emitEvictions(e) {
                if (typeof this.onEviction == "function")
                    for (let[t,i] of e)
                        this.onEviction(t, i.value)
            }
            _deleteIfExpired(e, t) {
                return typeof t.expiry == "number" && t.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, t.value),
                this.delete(e)) : !1
            }
            _getOrDeleteIfExpired(e, t) {
                if (this._deleteIfExpired(e, t) === !1)
                    return t.value
            }
            _getItemValue(e, t) {
                return t.expiry ? this._getOrDeleteIfExpired(e, t) : t.value
            }
            _peek(e, t) {
                let i = t.get(e);
                return this._getItemValue(e, i)
            }
            _set(e, t) {
                this.cache.set(e, t),
                this._size++,
                this._size >= this.maxSize && (this._size = 0,
                this._emitEvictions(this.oldCache),
                this.oldCache = this.cache,
                this.cache = new Map)
            }
            _moveToRecent(e, t) {
                this.oldCache.delete(e),
                this._set(e, t)
            }
            *_entriesAscending() {
                for (let e of this.oldCache) {
                    let[t,i] = e;
                    this.cache.has(t) || this._deleteIfExpired(t, i) === !1 && (yield e)
                }
                for (let e of this.cache) {
                    let[t,i] = e;
                    this._deleteIfExpired(t, i) === !1 && (yield e)
                }
            }
            get(e) {
                if (this.cache.has(e)) {
                    let t = this.cache.get(e);
                    return this._getItemValue(e, t)
                }
                if (this.oldCache.has(e)) {
                    let t = this.oldCache.get(e);
                    if (this._deleteIfExpired(e, t) === !1)
                        return this._moveToRecent(e, t),
                        t.value
                }
            }
            set(e, t, {maxAge: i=this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge}={}) {
                this.cache.has(e) ? this.cache.set(e, {
                    value: t,
                    maxAge: i
                }) : this._set(e, {
                    value: t,
                    expiry: i
                })
            }
            has(e) {
                return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1
            }
            peek(e) {
                if (this.cache.has(e))
                    return this._peek(e, this.cache);
                if (this.oldCache.has(e))
                    return this._peek(e, this.oldCache)
            }
            delete(e) {
                let t = this.cache.delete(e);
                return t && this._size--,
                this.oldCache.delete(e) || t
            }
            clear() {
                this.cache.clear(),
                this.oldCache.clear(),
                this._size = 0
            }
            resize(e) {
                if (!(e && e > 0))
                    throw new TypeError("`maxSize` must be a number greater than 0");
                let t = [...this._entriesAscending()]
                  , i = t.length - e;
                i < 0 ? (this.cache = new Map(t),
                this.oldCache = new Map,
                this._size = t.length) : (i > 0 && this._emitEvictions(t.slice(0, i)),
                this.oldCache = new Map(t.slice(i)),
                this.cache = new Map,
                this._size = 0),
                this.maxSize = e
            }
            *keys() {
                for (let[e] of this)
                    yield e
            }
            *values() {
                for (let[,e] of this)
                    yield e
            }
            *[Symbol.iterator]() {
                for (let e of this.cache) {
                    let[t,i] = e;
                    this._deleteIfExpired(t, i) === !1 && (yield[t, i.value])
                }
                for (let e of this.oldCache) {
                    let[t,i] = e;
                    this.cache.has(t) || this._deleteIfExpired(t, i) === !1 && (yield[t, i.value])
                }
            }
            *entriesDescending() {
                let e = [...this.cache];
                for (let t = e.length - 1; t >= 0; --t) {
                    let i = e[t]
                      , [n,s] = i;
                    this._deleteIfExpired(n, s) === !1 && (yield[n, s.value])
                }
                e = [...this.oldCache];
                for (let t = e.length - 1; t >= 0; --t) {
                    let i = e[t]
                      , [n,s] = i;
                    this.cache.has(n) || this._deleteIfExpired(n, s) === !1 && (yield[n, s.value])
                }
            }
            *entriesAscending() {
                for (let[e,t] of this._entriesAscending())
                    yield[e, t.value]
            }
            get size() {
                if (!this._size)
                    return this.oldCache.size;
                let e = 0;
                for (let t of this.oldCache.keys())
                    this.cache.has(t) || e++;
                return Math.min(this._size + e, this.maxSize)
            }
        }
        ;
        gf.exports = mf
    }
    );
    var yf, bf = P( () => {
        u();
        yf = r => r && r._hash
    }
    );
    function Wi(r) {
        return yf(r, {
            ignoreUnknown: !0
        })
    }
    var wf = P( () => {
        u();
        bf()
    }
    );
    function xt(r) {
        if (r = `${r}`,
        r === "0")
            return "0";
        if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(r))
            return r.replace(/^[+-]?/, t => t === "-" ? "" : "-");
        let e = ["var", "calc", "min", "max", "clamp"];
        for (let t of e)
            if (r.includes(`${t}(`))
                return `calc(${r} * -1)`
    }
    var Gi = P( () => {
        u()
    }
    );
    var vf, xf = P( () => {
        u();
        vf = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "size", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "textWrap", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "contain", "content", "forcedColorAdjust"]
    }
    );
    function kf(r, e) {
        return r === void 0 ? e : Array.isArray(r) ? r : [...new Set(e.filter(i => r !== !1 && r[i] !== !1).concat(Object.keys(r).filter(i => r[i] !== !1)))]
    }
